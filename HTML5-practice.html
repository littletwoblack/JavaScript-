<!--练习说明：请照着代码后面敲，然后删除，退出时候不做保存。这就是一个万用水字毛笔字帖。-->


<!--HTML5 Canvas

<canvas>元素是HTML5中的新元素，通过使用该元素，你可以在网页中绘制所需的图形。
标签定义图形，比如图表和其他图像，您必须使用脚本来绘制图形。

-->

<canvas id="mycanvas1"></canvas>
<canvas id="mycanvas2"></canvas>
<script>
    //在Canvas上画线，我们将使用以下两种方法：
    //moveTo(x,y) 定义线条开始坐标
    //lineTo(x,y) 定义线条结束坐标
    var c1=document.getElementById("mycanvas1");
    var ctx1=c1.getContext("2d");
    ctx1.moveTo(0,0);
    ctx1.lineTo(200,100);
    ctx1.stroke();
    //在canvas中绘制圆形, 我们将使用以下方法:
    //arc(x,y,r,start,stop)
    var c2=document.getElementById("myCanvas2"); 
    var ctx=c2.getContext("2d"); 
    ctx2.beginPath(); 
    ctx2.arc(95,50,40,0,2*Math.PI); 
    ctx2.stroke();    
    //绘制矩形
    ctx.fillStyle="#FF0000";        
    ctx.fillRect(0,0,150,75);//canvas 的左上角坐标为 (0,0)
    //上面的 fillRect 方法拥有参数 (0,0,150,75)。
    //意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。
</script>

<!--
Canvas - 文本

使用 canvas 绘制文本，重要的属性和方法如下：
font - 定义字体
fillText(text,x,y) - 在 canvas 上绘制实心的文本
strokeText(text,x,y) - 在 canvas 上绘制空心的文本
-->
<canvas id="mycanvas3"></canvas>
<script>
    var c3=document.getElementById("myCanvas3"); 
    var ctx3=c3.getContext("2d"); 
    ctx3.font="30px Arial"; 
    ctx3.fillText("Hello World",10,50);//实心字
    ctx3.strokeText("Hello World",10,50);//空心字
</script>

<!--
    Canvas - 图像

把一幅图像放置到画布上, 使用以下方法:
drawImage(image,x,y)
-->
<p>Image to use:</p>
<img id="scream" src="/attachments/image/20160224/1456314599613373.jpg" alt="The Scream" ><p>Canvas:</p>
<canvas id="myCanvas" width="250" height="300" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。</canvas>

<script>
    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");
    var img=document.getElementById("scream");

    img.onload = function() {
        ctx.drawImage(img,10,10);
    } 
</script>

<!--
 HTML5 内联 SVG

SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，
它在2003年1月14日成为W3C推荐标准。

SVG 与 Canvas两者间的区别

SVG 是一种使用 XML 描述 2D 图形的语言。
Canvas 通过 JavaScript 来绘制 2D 图形。
SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
Canvas 与 SVG 的比较

下表列出了 canvas 与 SVG 之间的一些不同之处。
Canvas	
依赖分辨率
不支持事件处理器
弱的文本渲染能力
能够以 .png 或 .jpg 格式保存结果图像
最适合图像密集型的游戏，其中的许多对象会被频繁重绘
SVG
不依赖分辨率
支持事件处理器
最适合带有大型渲染区域的应用程序（比如谷歌地图）
复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
不适合游戏应用
-->
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">
    <polygon points="100,10 40,180 190,60 10,60 160,180"
    style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;">
</svg>
  

<!--
    HTML5 MathML

MathML 与 HTML相似度很高，但是比较繁琐。它继承了角括号和双标签（<标签>内容</标签>）的用法。
HTML5 可以在文档中使用 MathML 元素，对应的标签是 <math>...</math> 。
MathML 是数学标记语言，是一种基于XML（标准通用标记语言的子集）的标准，用来在互联网上书写数学符号和公式的置标语言。
-->


<!--
    HTML5 Geolocation（地理定位）

HTML5 Geolocation（地理定位）用于定位用户的位置。
Geolocation 通过请求一个位置信息，用户同意后，浏览器会返回一个包含经度和维度的位置信息！
-->


<video width="320" height="240" controls>
        <source src="movie.mp4" type="video/mp4">
        <source src="movie.ogg" type="video/ogg">
      您的浏览器不支持Video标签。
</video>

<audio controls> 
        <source src="horse.ogg" type="audio/ogg"> 
        <source src="horse.mp3" type="audio/mpeg"> 
      您的浏览器不支持 audio 元素。 
</audio>

<!--
    HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。
本章全面介绍这些新的输入类型：
color
date
datetime
datetime-local
email
month
number
range
search
tel
time
url
week
注意:并不是所有的主流浏览器都支持新的input类型，不过您已经可以在所有主流的浏览器中使用它们了。
即使不被支持，仍然可以显示为常规的文本域。
-->
<input type="month">


<!--
    HTML5 新的表单元素

HTML5 有以下新的表单元素:
<datalist>
<keygen>
<output>
注意:不是所有的浏览器都支持HTML5 新的表单元素，但是你可以在使用它们，即使浏览器不支持表单属性，仍然可以显示为常规的表单元素。


<keygen> 元素的作用是提供一种验证用户的可靠方法。
<keygen>标签规定用于表单的密钥对生成器字段。
当提交表单时，会生成两个键，一个是私钥，一个公钥。
私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。
-->
<form action="/statics/demosource/demo-form.php" method="get">
    <input list="browsers" name="browser"   autofocus>
    <datalist id="browsers">
      <option value="Internet Explorer">
      <option value="Firefox">
      <option value="Chrome">
      <option value="Opera">
      <option value="Safari">
    </datalist>
    <input type="submit">
</form>

<form action="/statics/demosource/demo-form.php" method="get">
    用户名: <input type="text" name="usr_name">
    加密: <keygen name="security">
    <input type="submit">
</form>


<!--
    HTML5中新的语义元素

许多现有网站都包含以下HTML代码： <div id="nav">, <div class="header">, 或者 <div id="footer">, 来指明导航链接, 头部, 以及尾部.
HTML5提供了新的语义元素来明确一个Web页面的不同部分:
<header>
<nav>
<section>
<article>
<aside>
<figcaption>
<figure>
<footer>

-->


<!--
    什么是 HTML5 Web 存储?

使用HTML5可以在本地存储用户的浏览数据。
早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。
数据以键/值对存在, web网页的数据只允许该网页访问使用。

localStorage 和 sessionStorage 

客户端存储数据的两个对象为：
localStorage - 没有时间限制的数据存储
sessionStorage - 针对一个 session 的数据存储
在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage:    

不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 
保存数据：localStorage.setItem(key,value);
读取数据：localStorage.getItem(key);
删除单个数据：localStorage.removeItem(key);
删除所有数据：localStorage.clear();
得到某个索引的key：localStorage.key(index);

sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。
-->


<script>
    // 存储
    localStorage.sitename = "W3Cschool在线教程";
    // 查找
    document.getElementById("result").innerHTML = localStorage.sitename;
    //移除 localStorage 中的 "lastname" : 
    localStorage.removeItem("lastname");
</script>

<script>
    //下面的实例展示了用户点击按钮的次数。
    //代码中的字符串值转换为数字类型:

    if (localStorage.clickcount) 
    { 
    localStorage.clickcount=Number(localStorage.clickcount)+1; 
    } 
    else 
    { 
    localStorage.clickcount=1; 
    } 
    document.getElementById("result").innerHTML=" 你已经点击了按钮 " + localStorage.clickcount + " 次 ";

    //使用sessionstorage，回话结束后变量将会被删除。
    if (sessionStorage.clickcount) 
    { 
    sessionStorage.clickcount=Number(sessionStorage.clickcount)+1; 
    } 
    else 
    { 
    sessionStorage.clickcount=1; 
    } 
    document.getElementById("result").innerHTML="在这个会话中你已经点击了该按钮 " + sessionStorage.clickcount + " 次 ";
</script>




<!--
    HTML5 Web SQL 数据库

Web SQL 是在浏览器上模拟数据库，可以使用JS来操作SQL完成对数据的读写。
Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。

核心方法

以下是规范中定义的三个核心方法：
openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。
transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。
executeSql：这个方法用于执行实际的 SQL 查询。
-->
<script>
    //打开数据库

    //我们可以使用 openDatabase() 方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库，使用代码如下：
    var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
    /*openDatabase() 方法对应的五个参数说明：
    数据库名称
    版本号
    描述文本
    数据库大小
    创建回调
    第五个参数，创建回调会在创建数据库后被调用。*/

    //执行查询操作

    //执行操作使用 database.transaction() 函数：
    db.transaction(function (tx) {  
    tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
    //上面的语句执行后会在 'mydb' 数据库中创建一个名为 LOGS 的表。

    //再接着，我们可以插入一些数据
    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, "W3Cschool教程")');
    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, "www.w3cschool.cn")');
    //使用动态值来插入数据，实例中的 e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 "?"。
    tx.executeSql('INSERT INTO LOGS (id,log) VALUES (?, ?'), [e_id, e_log];
    });
</script>

<script>
    //以下实例演示了如何读取数据库中已经存在的数据：
    var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);

    db.transaction(function (tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, "W3Cschool教程")');
    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, "www.w3cschool.cn")');
    });

    db.transaction(function (tx) {
    tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
        var len = results.rows.length, i;
        msg = " 查询记录条数: " + len + "";
        document.querySelector('#status').innerHTML +=  msg;
        
        for (i = 0; i < len; i++){
            alert(results.rows.item(i).log );
        }
        
    }, null);
    });

    //删除记录使用的格式如下：
    db.transaction(function (tx) {
        tx.executeSql('DELETE FROM LOGS  WHERE id=1');
    });
    //删除指定的数据id也可以是动态的：
    db.transaction(function(tx) {
        tx.executeSql('DELETE FROM LOGS WHERE id=?', [id]);
    });
    //更新记录

    //更新记录使用的格式如下：
    db.transaction(function (tx) {
        tx.executeSql('UPDATE LOGS SET log=\'www.w3cschool.cn\' WHERE id=2');
    });
    //更新指定的数据id也可以是动态的：
    db.transaction(function(tx) {
        tx.executeSql('UPDATE LOGS SET log=\'www.w3cschool.cn\' WHERE id=?', [id]);
    });

</script>



<!--
    HTML5 应用程序缓存

使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。这意味着，你可以在没有网络连接的情况下进行访问。
什么是应用程序缓存（Application Cache）？

HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。
应用程序缓存为应用带来三个优势：
离线浏览 - 用户可在应用离线时使用它们
速度 - 已缓存资源加载得更快
减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。

-->


<!--
    HTML5 Web Workers

web worker 是运行在后台的 JavaScript，不会影响页面的性能，更好的解释是，你可以使用web worker提供的一种简单的方法来为web内容在后台线程中运行脚本，这些线程在执行任务的过程中并不会干扰用户界面！
什么是 Web Worker？

当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。
web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

-->



<!--
    HTML5 服务器发送事件(Server-Sent Events)

服务器发送事件（Server-sent Events）是基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯。
HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。
Server-Sent 事件 - 单向消息传递

Server-Sent 事件指的是网页自动获取来自服务器的更新。
以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。
例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。
-->


<!--
    HTML5 WebSocket

WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。
在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。
当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。
以下 API 用于创建 WebSocket 对象。
var Socket = new WebSocket(url, [protocal] );
以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。
-->

<script>
    var Socket = new WebSocket(url, [protocal] );

</script>
<script type="text/javascript">
    function WebSocketTest()
    {
       if ("WebSocket" in window)
       {
          alert("您的浏览器支持 WebSocket!");
          
          // 打开一个 web socket
          var ws = new WebSocket("ws://localhost:9998/echo");
           
          ws.onopen = function()
          {
             // Web Socket 已连接上，使用 send() 方法发送数据
             ws.send("发送数据");
             alert("数据发送中...");
          };
           
          ws.onmessage = function (evt) 
          { 
             var received_msg = evt.data;
             alert("数据已接收...");
          };
           
          ws.onclose = function()
          { 
             // 关闭 websocket
             alert("连接已关闭..."); 
          };
       }
       
       else
       {
          // 浏览器不支持 WebSocket
          alert("您的浏览器不支持 WebSocket!");
       }
    }
 </script>

 